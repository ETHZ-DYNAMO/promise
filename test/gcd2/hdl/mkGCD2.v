//
// Generated by Bluespec Compiler, version untagged-gb42c5f09 (build b42c5f09)
//
// On Wed Jul  2 16:51:40 CEST 2025
//
//
// Ports:
// Name                         I/O  size props
// RDY_start                      O     1
// getResult                      O    32
// RDY_getResult                  O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// start_a                        I    32
// start_b                        I    32
// EN_start                       I     1
// EN_getResult                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkGCD2(CLK,
              RST_N,

              start_a,
              start_b,
              EN_start,
              RDY_start,

              EN_getResult,
              getResult,
              RDY_getResult);
  input  CLK;
  input  RST_N;

  // action method start
  input  [31 : 0] start_a;
  input  [31 : 0] start_b;
  input  EN_start;
  output RDY_start;

  // actionvalue method getResult
  input  EN_getResult;
  output [31 : 0] getResult;
  output RDY_getResult;

  // signals for module outputs
  wire [31 : 0] getResult;
  wire RDY_getResult, RDY_start;

  // register turn
  reg turn;
  wire turn$D_IN, turn$EN;

  // ports of submodule bk
  wire bk$CLR, bk$DEQ, bk$D_IN, bk$D_OUT, bk$EMPTY_N, bk$ENQ, bk$FULL_N;

  // ports of submodule gcd1
  wire [31 : 0] gcd1$getResult, gcd1$start_a, gcd1$start_b;
  wire gcd1$EN_getResult, gcd1$EN_start, gcd1$RDY_getResult, gcd1$RDY_start;

  // ports of submodule gcd2
  wire [31 : 0] gcd2$getResult, gcd2$start_a, gcd2$start_b;
  wire gcd2$EN_getResult, gcd2$EN_start, gcd2$RDY_getResult, gcd2$RDY_start;

  // action method start
  assign RDY_start = bk$FULL_N && (turn ? gcd1$RDY_start : gcd2$RDY_start) ;

  // actionvalue method getResult
  assign getResult = bk$D_OUT ? gcd1$getResult : gcd2$getResult ;
  assign RDY_getResult =
             bk$EMPTY_N &&
             (bk$D_OUT ? gcd1$RDY_getResult : gcd2$RDY_getResult) ;

  // submodule bk
  FIFO2 #(.width(32'd1), .guarded(1'd1)) bk(.RST(RST_N),
                                            .CLK(CLK),
                                            .D_IN(bk$D_IN),
                                            .ENQ(bk$ENQ),
                                            .DEQ(bk$DEQ),
                                            .CLR(bk$CLR),
                                            .D_OUT(bk$D_OUT),
                                            .FULL_N(bk$FULL_N),
                                            .EMPTY_N(bk$EMPTY_N));

  // submodule gcd1
  mkGCDGuarded gcd1(.CLK(CLK),
                    .RST_N(RST_N),
                    .start_a(gcd1$start_a),
                    .start_b(gcd1$start_b),
                    .EN_start(gcd1$EN_start),
                    .EN_getResult(gcd1$EN_getResult),
                    .RDY_start(gcd1$RDY_start),
                    .getResult(gcd1$getResult),
                    .RDY_getResult(gcd1$RDY_getResult));

  // submodule gcd2
  mkGCDGuarded gcd2(.CLK(CLK),
                    .RST_N(RST_N),
                    .start_a(gcd2$start_a),
                    .start_b(gcd2$start_b),
                    .EN_start(gcd2$EN_start),
                    .EN_getResult(gcd2$EN_getResult),
                    .RDY_start(gcd2$RDY_start),
                    .getResult(gcd2$getResult),
                    .RDY_getResult(gcd2$RDY_getResult));

  // register turn
  assign turn$D_IN = !turn ;
  assign turn$EN = EN_start ;

  // submodule bk
  assign bk$D_IN = turn ;
  assign bk$ENQ = EN_start ;
  assign bk$DEQ = EN_getResult ;
  assign bk$CLR = 1'b0 ;

  // submodule gcd1
  assign gcd1$start_a = start_a ;
  assign gcd1$start_b = start_b ;
  assign gcd1$EN_start = EN_start && turn ;
  assign gcd1$EN_getResult = EN_getResult && bk$D_OUT ;

  // submodule gcd2
  assign gcd2$start_a = start_a ;
  assign gcd2$start_b = start_b ;
  assign gcd2$EN_start = EN_start && !turn ;
  assign gcd2$EN_getResult = EN_getResult && !bk$D_OUT ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        turn <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (turn$EN) turn <= `BSV_ASSIGNMENT_DELAY turn$D_IN;
      end
  end

  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    turn = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
endmodule  // mkGCD2

